// Generated by Cap'n Proto compiler, DO NOT EDIT
// source: custom.capnp

#pragma once

#include <capnp/generated-header-support.h>
#include <kj/windows-sanity.h>

#ifndef CAPNP_VERSION
#error "CAPNP_VERSION is not defined, is capnp/generated-header-support.h missing?"
#elif CAPNP_VERSION != 1000002
#error "Version mismatch between generated code and library headers.  You must use the same version of the Cap'n Proto compiler and library."
#endif

#include "car.capnp.h"

CAPNP_BEGIN_HEADER

namespace capnp {
namespace schemas {

CAPNP_DECLARE_SCHEMA(81c2f05a394cf4af);
CAPNP_DECLARE_SCHEMA(aedffd8f31e7b55d);
CAPNP_DECLARE_SCHEMA(d44714e202f6523f);
CAPNP_DECLARE_SCHEMA(e8d6933f4603150c);
enum class Type_e8d6933f4603150c: uint16_t {
  LKAS,
};
CAPNP_DECLARE_ENUM(Type, e8d6933f4603150c);
CAPNP_DECLARE_SCHEMA(f35cc4560bbf6ec2);
CAPNP_DECLARE_SCHEMA(da96579883444c35);
CAPNP_DECLARE_SCHEMA(80ae746ee2596b11);
CAPNP_DECLARE_SCHEMA(a5cd762cd951a455);
CAPNP_DECLARE_SCHEMA(f98d843bfd7004a3);
CAPNP_DECLARE_SCHEMA(b86e6369214c01c8);
CAPNP_DECLARE_SCHEMA(f416ec09499d9d19);
CAPNP_DECLARE_SCHEMA(a1680744031fdb2d);

}  // namespace schemas
}  // namespace capnp

namespace cereal {

struct FrogPilotCarControl {
  FrogPilotCarControl() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(81c2f05a394cf4af, 1, 0)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct FrogPilotCarState {
  FrogPilotCarState() = delete;

  class Reader;
  class Builder;
  class Pipeline;
  struct ButtonEvent;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(aedffd8f31e7b55d, 1, 0)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct FrogPilotCarState::ButtonEvent {
  ButtonEvent() = delete;

  class Reader;
  class Builder;
  class Pipeline;
  typedef ::capnp::schemas::Type_e8d6933f4603150c Type;


  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(d44714e202f6523f, 0, 0)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct FrogPilotDeviceState {
  FrogPilotDeviceState() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(f35cc4560bbf6ec2, 1, 0)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct FrogPilotNavigation {
  FrogPilotNavigation() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(da96579883444c35, 1, 0)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct FrogPilotPlan {
  FrogPilotPlan() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(80ae746ee2596b11, 12, 2)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct CustomReserved5 {
  CustomReserved5() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(a5cd762cd951a455, 0, 0)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct CustomReserved6 {
  CustomReserved6() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(f98d843bfd7004a3, 0, 0)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct CustomReserved7 {
  CustomReserved7() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(b86e6369214c01c8, 0, 0)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct CustomReserved8 {
  CustomReserved8() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(f416ec09499d9d19, 0, 0)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct CustomReserved9 {
  CustomReserved9() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(a1680744031fdb2d, 0, 0)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

// =======================================================================================

class FrogPilotCarControl::Reader {
public:
  typedef FrogPilotCarControl Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool getAccelPressed() const;

  inline bool getAlwaysOnLateralActive() const;

  inline bool getDecelPressed() const;

  inline bool getFcwEventTriggered() const;

  inline bool getNoEntryEventTriggered() const;

  inline bool getSteerSaturatedEventTriggered() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class FrogPilotCarControl::Builder {
public:
  typedef FrogPilotCarControl Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool getAccelPressed();
  inline void setAccelPressed(bool value);

  inline bool getAlwaysOnLateralActive();
  inline void setAlwaysOnLateralActive(bool value);

  inline bool getDecelPressed();
  inline void setDecelPressed(bool value);

  inline bool getFcwEventTriggered();
  inline void setFcwEventTriggered(bool value);

  inline bool getNoEntryEventTriggered();
  inline void setNoEntryEventTriggered(bool value);

  inline bool getSteerSaturatedEventTriggered();
  inline void setSteerSaturatedEventTriggered(bool value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class FrogPilotCarControl::Pipeline {
public:
  typedef FrogPilotCarControl Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class FrogPilotCarState::Reader {
public:
  typedef FrogPilotCarState Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool getAlwaysOnLateralEnabled() const;

  inline bool getBrakeLights() const;

  inline float getDashboardSpeedLimit() const;

  inline bool getDistanceLongPressed() const;

  inline bool getEcoGear() const;

  inline bool getHasMenu() const;

  inline bool getSportGear() const;

  inline bool getTrafficModeActive() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class FrogPilotCarState::Builder {
public:
  typedef FrogPilotCarState Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool getAlwaysOnLateralEnabled();
  inline void setAlwaysOnLateralEnabled(bool value);

  inline bool getBrakeLights();
  inline void setBrakeLights(bool value);

  inline float getDashboardSpeedLimit();
  inline void setDashboardSpeedLimit(float value);

  inline bool getDistanceLongPressed();
  inline void setDistanceLongPressed(bool value);

  inline bool getEcoGear();
  inline void setEcoGear(bool value);

  inline bool getHasMenu();
  inline void setHasMenu(bool value);

  inline bool getSportGear();
  inline void setSportGear(bool value);

  inline bool getTrafficModeActive();
  inline void setTrafficModeActive(bool value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class FrogPilotCarState::Pipeline {
public:
  typedef FrogPilotCarState Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class FrogPilotCarState::ButtonEvent::Reader {
public:
  typedef ButtonEvent Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class FrogPilotCarState::ButtonEvent::Builder {
public:
  typedef ButtonEvent Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class FrogPilotCarState::ButtonEvent::Pipeline {
public:
  typedef ButtonEvent Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class FrogPilotDeviceState::Reader {
public:
  typedef FrogPilotDeviceState Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline  ::int16_t getFreeSpace() const;

  inline  ::int16_t getUsedSpace() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class FrogPilotDeviceState::Builder {
public:
  typedef FrogPilotDeviceState Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline  ::int16_t getFreeSpace();
  inline void setFreeSpace( ::int16_t value);

  inline  ::int16_t getUsedSpace();
  inline void setUsedSpace( ::int16_t value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class FrogPilotDeviceState::Pipeline {
public:
  typedef FrogPilotDeviceState Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class FrogPilotNavigation::Reader {
public:
  typedef FrogPilotNavigation Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool getApproachingIntersection() const;

  inline bool getApproachingTurn() const;

  inline float getNavigationSpeedLimit() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class FrogPilotNavigation::Builder {
public:
  typedef FrogPilotNavigation Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool getApproachingIntersection();
  inline void setApproachingIntersection(bool value);

  inline bool getApproachingTurn();
  inline void setApproachingTurn(bool value);

  inline float getNavigationSpeedLimit();
  inline void setNavigationSpeedLimit(float value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class FrogPilotNavigation::Pipeline {
public:
  typedef FrogPilotNavigation Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class FrogPilotPlan::Reader {
public:
  typedef FrogPilotPlan Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline float getAccelerationJerk() const;

  inline float getAccelerationJerkStock() const;

  inline float getDangerJerk() const;

  inline  ::int64_t getDesiredFollowDistance() const;

  inline bool getExperimentalMode() const;

  inline bool getForcingStop() const;

  inline float getForcingStopLength() const;

  inline bool hasFrogpilotEvents() const;
  inline  ::capnp::List< ::cereal::CarEvent,  ::capnp::Kind::STRUCT>::Reader getFrogpilotEvents() const;

  inline bool getLateralCheck() const;

  inline float getLaneWidthLeft() const;

  inline float getLaneWidthRight() const;

  inline float getMaxAcceleration() const;

  inline float getMinAcceleration() const;

  inline float getMtscSpeed() const;

  inline bool getRedLight() const;

  inline float getSlcMapSpeedLimit() const;

  inline bool getSlcOverridden() const;

  inline float getSlcOverriddenSpeed() const;

  inline float getSlcSpeedLimit() const;

  inline float getSlcSpeedLimitOffset() const;

  inline bool hasSlcSpeedLimitSource() const;
  inline  ::capnp::Text::Reader getSlcSpeedLimitSource() const;

  inline float getSpeedJerk() const;

  inline float getSpeedJerkStock() const;

  inline bool getSpeedLimitChanged() const;

  inline bool getStscControllingCurve() const;

  inline float getStscSpeed() const;

  inline float getTFollow() const;

  inline bool getTogglesUpdated() const;

  inline float getUnconfirmedSlcSpeedLimit() const;

  inline float getUpcomingSLCSpeedLimit() const;

  inline float getVCruise() const;

  inline bool getVtscControllingCurve() const;

  inline float getVtscSpeed() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class FrogPilotPlan::Builder {
public:
  typedef FrogPilotPlan Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline float getAccelerationJerk();
  inline void setAccelerationJerk(float value);

  inline float getAccelerationJerkStock();
  inline void setAccelerationJerkStock(float value);

  inline float getDangerJerk();
  inline void setDangerJerk(float value);

  inline  ::int64_t getDesiredFollowDistance();
  inline void setDesiredFollowDistance( ::int64_t value);

  inline bool getExperimentalMode();
  inline void setExperimentalMode(bool value);

  inline bool getForcingStop();
  inline void setForcingStop(bool value);

  inline float getForcingStopLength();
  inline void setForcingStopLength(float value);

  inline bool hasFrogpilotEvents();
  inline  ::capnp::List< ::cereal::CarEvent,  ::capnp::Kind::STRUCT>::Builder getFrogpilotEvents();
  inline void setFrogpilotEvents( ::capnp::List< ::cereal::CarEvent,  ::capnp::Kind::STRUCT>::Reader value);
  inline  ::capnp::List< ::cereal::CarEvent,  ::capnp::Kind::STRUCT>::Builder initFrogpilotEvents(unsigned int size);
  inline void adoptFrogpilotEvents(::capnp::Orphan< ::capnp::List< ::cereal::CarEvent,  ::capnp::Kind::STRUCT>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::cereal::CarEvent,  ::capnp::Kind::STRUCT>> disownFrogpilotEvents();

  inline bool getLateralCheck();
  inline void setLateralCheck(bool value);

  inline float getLaneWidthLeft();
  inline void setLaneWidthLeft(float value);

  inline float getLaneWidthRight();
  inline void setLaneWidthRight(float value);

  inline float getMaxAcceleration();
  inline void setMaxAcceleration(float value);

  inline float getMinAcceleration();
  inline void setMinAcceleration(float value);

  inline float getMtscSpeed();
  inline void setMtscSpeed(float value);

  inline bool getRedLight();
  inline void setRedLight(bool value);

  inline float getSlcMapSpeedLimit();
  inline void setSlcMapSpeedLimit(float value);

  inline bool getSlcOverridden();
  inline void setSlcOverridden(bool value);

  inline float getSlcOverriddenSpeed();
  inline void setSlcOverriddenSpeed(float value);

  inline float getSlcSpeedLimit();
  inline void setSlcSpeedLimit(float value);

  inline float getSlcSpeedLimitOffset();
  inline void setSlcSpeedLimitOffset(float value);

  inline bool hasSlcSpeedLimitSource();
  inline  ::capnp::Text::Builder getSlcSpeedLimitSource();
  inline void setSlcSpeedLimitSource( ::capnp::Text::Reader value);
  inline  ::capnp::Text::Builder initSlcSpeedLimitSource(unsigned int size);
  inline void adoptSlcSpeedLimitSource(::capnp::Orphan< ::capnp::Text>&& value);
  inline ::capnp::Orphan< ::capnp::Text> disownSlcSpeedLimitSource();

  inline float getSpeedJerk();
  inline void setSpeedJerk(float value);

  inline float getSpeedJerkStock();
  inline void setSpeedJerkStock(float value);

  inline bool getSpeedLimitChanged();
  inline void setSpeedLimitChanged(bool value);

  inline bool getStscControllingCurve();
  inline void setStscControllingCurve(bool value);

  inline float getStscSpeed();
  inline void setStscSpeed(float value);

  inline float getTFollow();
  inline void setTFollow(float value);

  inline bool getTogglesUpdated();
  inline void setTogglesUpdated(bool value);

  inline float getUnconfirmedSlcSpeedLimit();
  inline void setUnconfirmedSlcSpeedLimit(float value);

  inline float getUpcomingSLCSpeedLimit();
  inline void setUpcomingSLCSpeedLimit(float value);

  inline float getVCruise();
  inline void setVCruise(float value);

  inline bool getVtscControllingCurve();
  inline void setVtscControllingCurve(bool value);

  inline float getVtscSpeed();
  inline void setVtscSpeed(float value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class FrogPilotPlan::Pipeline {
public:
  typedef FrogPilotPlan Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class CustomReserved5::Reader {
public:
  typedef CustomReserved5 Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class CustomReserved5::Builder {
public:
  typedef CustomReserved5 Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class CustomReserved5::Pipeline {
public:
  typedef CustomReserved5 Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class CustomReserved6::Reader {
public:
  typedef CustomReserved6 Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class CustomReserved6::Builder {
public:
  typedef CustomReserved6 Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class CustomReserved6::Pipeline {
public:
  typedef CustomReserved6 Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class CustomReserved7::Reader {
public:
  typedef CustomReserved7 Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class CustomReserved7::Builder {
public:
  typedef CustomReserved7 Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class CustomReserved7::Pipeline {
public:
  typedef CustomReserved7 Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class CustomReserved8::Reader {
public:
  typedef CustomReserved8 Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class CustomReserved8::Builder {
public:
  typedef CustomReserved8 Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class CustomReserved8::Pipeline {
public:
  typedef CustomReserved8 Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class CustomReserved9::Reader {
public:
  typedef CustomReserved9 Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class CustomReserved9::Builder {
public:
  typedef CustomReserved9 Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class CustomReserved9::Pipeline {
public:
  typedef CustomReserved9 Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

// =======================================================================================

inline bool FrogPilotCarControl::Reader::getAccelPressed() const {
  return _reader.getDataField<bool>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline bool FrogPilotCarControl::Builder::getAccelPressed() {
  return _builder.getDataField<bool>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void FrogPilotCarControl::Builder::setAccelPressed(bool value) {
  _builder.setDataField<bool>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline bool FrogPilotCarControl::Reader::getAlwaysOnLateralActive() const {
  return _reader.getDataField<bool>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}

inline bool FrogPilotCarControl::Builder::getAlwaysOnLateralActive() {
  return _builder.getDataField<bool>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}
inline void FrogPilotCarControl::Builder::setAlwaysOnLateralActive(bool value) {
  _builder.setDataField<bool>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, value);
}

inline bool FrogPilotCarControl::Reader::getDecelPressed() const {
  return _reader.getDataField<bool>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS);
}

inline bool FrogPilotCarControl::Builder::getDecelPressed() {
  return _builder.getDataField<bool>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS);
}
inline void FrogPilotCarControl::Builder::setDecelPressed(bool value) {
  _builder.setDataField<bool>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS, value);
}

inline bool FrogPilotCarControl::Reader::getFcwEventTriggered() const {
  return _reader.getDataField<bool>(
      ::capnp::bounded<3>() * ::capnp::ELEMENTS);
}

inline bool FrogPilotCarControl::Builder::getFcwEventTriggered() {
  return _builder.getDataField<bool>(
      ::capnp::bounded<3>() * ::capnp::ELEMENTS);
}
inline void FrogPilotCarControl::Builder::setFcwEventTriggered(bool value) {
  _builder.setDataField<bool>(
      ::capnp::bounded<3>() * ::capnp::ELEMENTS, value);
}

inline bool FrogPilotCarControl::Reader::getNoEntryEventTriggered() const {
  return _reader.getDataField<bool>(
      ::capnp::bounded<4>() * ::capnp::ELEMENTS);
}

inline bool FrogPilotCarControl::Builder::getNoEntryEventTriggered() {
  return _builder.getDataField<bool>(
      ::capnp::bounded<4>() * ::capnp::ELEMENTS);
}
inline void FrogPilotCarControl::Builder::setNoEntryEventTriggered(bool value) {
  _builder.setDataField<bool>(
      ::capnp::bounded<4>() * ::capnp::ELEMENTS, value);
}

inline bool FrogPilotCarControl::Reader::getSteerSaturatedEventTriggered() const {
  return _reader.getDataField<bool>(
      ::capnp::bounded<5>() * ::capnp::ELEMENTS);
}

inline bool FrogPilotCarControl::Builder::getSteerSaturatedEventTriggered() {
  return _builder.getDataField<bool>(
      ::capnp::bounded<5>() * ::capnp::ELEMENTS);
}
inline void FrogPilotCarControl::Builder::setSteerSaturatedEventTriggered(bool value) {
  _builder.setDataField<bool>(
      ::capnp::bounded<5>() * ::capnp::ELEMENTS, value);
}

inline bool FrogPilotCarState::Reader::getAlwaysOnLateralEnabled() const {
  return _reader.getDataField<bool>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline bool FrogPilotCarState::Builder::getAlwaysOnLateralEnabled() {
  return _builder.getDataField<bool>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void FrogPilotCarState::Builder::setAlwaysOnLateralEnabled(bool value) {
  _builder.setDataField<bool>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline bool FrogPilotCarState::Reader::getBrakeLights() const {
  return _reader.getDataField<bool>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}

inline bool FrogPilotCarState::Builder::getBrakeLights() {
  return _builder.getDataField<bool>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}
inline void FrogPilotCarState::Builder::setBrakeLights(bool value) {
  _builder.setDataField<bool>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, value);
}

inline float FrogPilotCarState::Reader::getDashboardSpeedLimit() const {
  return _reader.getDataField<float>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}

inline float FrogPilotCarState::Builder::getDashboardSpeedLimit() {
  return _builder.getDataField<float>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}
inline void FrogPilotCarState::Builder::setDashboardSpeedLimit(float value) {
  _builder.setDataField<float>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, value);
}

inline bool FrogPilotCarState::Reader::getDistanceLongPressed() const {
  return _reader.getDataField<bool>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS);
}

inline bool FrogPilotCarState::Builder::getDistanceLongPressed() {
  return _builder.getDataField<bool>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS);
}
inline void FrogPilotCarState::Builder::setDistanceLongPressed(bool value) {
  _builder.setDataField<bool>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS, value);
}

inline bool FrogPilotCarState::Reader::getEcoGear() const {
  return _reader.getDataField<bool>(
      ::capnp::bounded<3>() * ::capnp::ELEMENTS);
}

inline bool FrogPilotCarState::Builder::getEcoGear() {
  return _builder.getDataField<bool>(
      ::capnp::bounded<3>() * ::capnp::ELEMENTS);
}
inline void FrogPilotCarState::Builder::setEcoGear(bool value) {
  _builder.setDataField<bool>(
      ::capnp::bounded<3>() * ::capnp::ELEMENTS, value);
}

inline bool FrogPilotCarState::Reader::getHasMenu() const {
  return _reader.getDataField<bool>(
      ::capnp::bounded<4>() * ::capnp::ELEMENTS);
}

inline bool FrogPilotCarState::Builder::getHasMenu() {
  return _builder.getDataField<bool>(
      ::capnp::bounded<4>() * ::capnp::ELEMENTS);
}
inline void FrogPilotCarState::Builder::setHasMenu(bool value) {
  _builder.setDataField<bool>(
      ::capnp::bounded<4>() * ::capnp::ELEMENTS, value);
}

inline bool FrogPilotCarState::Reader::getSportGear() const {
  return _reader.getDataField<bool>(
      ::capnp::bounded<5>() * ::capnp::ELEMENTS);
}

inline bool FrogPilotCarState::Builder::getSportGear() {
  return _builder.getDataField<bool>(
      ::capnp::bounded<5>() * ::capnp::ELEMENTS);
}
inline void FrogPilotCarState::Builder::setSportGear(bool value) {
  _builder.setDataField<bool>(
      ::capnp::bounded<5>() * ::capnp::ELEMENTS, value);
}

inline bool FrogPilotCarState::Reader::getTrafficModeActive() const {
  return _reader.getDataField<bool>(
      ::capnp::bounded<6>() * ::capnp::ELEMENTS);
}

inline bool FrogPilotCarState::Builder::getTrafficModeActive() {
  return _builder.getDataField<bool>(
      ::capnp::bounded<6>() * ::capnp::ELEMENTS);
}
inline void FrogPilotCarState::Builder::setTrafficModeActive(bool value) {
  _builder.setDataField<bool>(
      ::capnp::bounded<6>() * ::capnp::ELEMENTS, value);
}

inline  ::int16_t FrogPilotDeviceState::Reader::getFreeSpace() const {
  return _reader.getDataField< ::int16_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::int16_t FrogPilotDeviceState::Builder::getFreeSpace() {
  return _builder.getDataField< ::int16_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void FrogPilotDeviceState::Builder::setFreeSpace( ::int16_t value) {
  _builder.setDataField< ::int16_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline  ::int16_t FrogPilotDeviceState::Reader::getUsedSpace() const {
  return _reader.getDataField< ::int16_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}

inline  ::int16_t FrogPilotDeviceState::Builder::getUsedSpace() {
  return _builder.getDataField< ::int16_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}
inline void FrogPilotDeviceState::Builder::setUsedSpace( ::int16_t value) {
  _builder.setDataField< ::int16_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, value);
}

inline bool FrogPilotNavigation::Reader::getApproachingIntersection() const {
  return _reader.getDataField<bool>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline bool FrogPilotNavigation::Builder::getApproachingIntersection() {
  return _builder.getDataField<bool>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void FrogPilotNavigation::Builder::setApproachingIntersection(bool value) {
  _builder.setDataField<bool>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline bool FrogPilotNavigation::Reader::getApproachingTurn() const {
  return _reader.getDataField<bool>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}

inline bool FrogPilotNavigation::Builder::getApproachingTurn() {
  return _builder.getDataField<bool>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}
inline void FrogPilotNavigation::Builder::setApproachingTurn(bool value) {
  _builder.setDataField<bool>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, value);
}

inline float FrogPilotNavigation::Reader::getNavigationSpeedLimit() const {
  return _reader.getDataField<float>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}

inline float FrogPilotNavigation::Builder::getNavigationSpeedLimit() {
  return _builder.getDataField<float>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}
inline void FrogPilotNavigation::Builder::setNavigationSpeedLimit(float value) {
  _builder.setDataField<float>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, value);
}

inline float FrogPilotPlan::Reader::getAccelerationJerk() const {
  return _reader.getDataField<float>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline float FrogPilotPlan::Builder::getAccelerationJerk() {
  return _builder.getDataField<float>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void FrogPilotPlan::Builder::setAccelerationJerk(float value) {
  _builder.setDataField<float>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline float FrogPilotPlan::Reader::getAccelerationJerkStock() const {
  return _reader.getDataField<float>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}

inline float FrogPilotPlan::Builder::getAccelerationJerkStock() {
  return _builder.getDataField<float>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}
inline void FrogPilotPlan::Builder::setAccelerationJerkStock(float value) {
  _builder.setDataField<float>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, value);
}

inline float FrogPilotPlan::Reader::getDangerJerk() const {
  return _reader.getDataField<float>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS);
}

inline float FrogPilotPlan::Builder::getDangerJerk() {
  return _builder.getDataField<float>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS);
}
inline void FrogPilotPlan::Builder::setDangerJerk(float value) {
  _builder.setDataField<float>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS, value);
}

inline  ::int64_t FrogPilotPlan::Reader::getDesiredFollowDistance() const {
  return _reader.getDataField< ::int64_t>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS);
}

inline  ::int64_t FrogPilotPlan::Builder::getDesiredFollowDistance() {
  return _builder.getDataField< ::int64_t>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS);
}
inline void FrogPilotPlan::Builder::setDesiredFollowDistance( ::int64_t value) {
  _builder.setDataField< ::int64_t>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS, value);
}

inline bool FrogPilotPlan::Reader::getExperimentalMode() const {
  return _reader.getDataField<bool>(
      ::capnp::bounded<96>() * ::capnp::ELEMENTS);
}

inline bool FrogPilotPlan::Builder::getExperimentalMode() {
  return _builder.getDataField<bool>(
      ::capnp::bounded<96>() * ::capnp::ELEMENTS);
}
inline void FrogPilotPlan::Builder::setExperimentalMode(bool value) {
  _builder.setDataField<bool>(
      ::capnp::bounded<96>() * ::capnp::ELEMENTS, value);
}

inline bool FrogPilotPlan::Reader::getForcingStop() const {
  return _reader.getDataField<bool>(
      ::capnp::bounded<97>() * ::capnp::ELEMENTS);
}

inline bool FrogPilotPlan::Builder::getForcingStop() {
  return _builder.getDataField<bool>(
      ::capnp::bounded<97>() * ::capnp::ELEMENTS);
}
inline void FrogPilotPlan::Builder::setForcingStop(bool value) {
  _builder.setDataField<bool>(
      ::capnp::bounded<97>() * ::capnp::ELEMENTS, value);
}

inline float FrogPilotPlan::Reader::getForcingStopLength() const {
  return _reader.getDataField<float>(
      ::capnp::bounded<6>() * ::capnp::ELEMENTS);
}

inline float FrogPilotPlan::Builder::getForcingStopLength() {
  return _builder.getDataField<float>(
      ::capnp::bounded<6>() * ::capnp::ELEMENTS);
}
inline void FrogPilotPlan::Builder::setForcingStopLength(float value) {
  _builder.setDataField<float>(
      ::capnp::bounded<6>() * ::capnp::ELEMENTS, value);
}

inline bool FrogPilotPlan::Reader::hasFrogpilotEvents() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool FrogPilotPlan::Builder::hasFrogpilotEvents() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::cereal::CarEvent,  ::capnp::Kind::STRUCT>::Reader FrogPilotPlan::Reader::getFrogpilotEvents() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::cereal::CarEvent,  ::capnp::Kind::STRUCT>>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::List< ::cereal::CarEvent,  ::capnp::Kind::STRUCT>::Builder FrogPilotPlan::Builder::getFrogpilotEvents() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::cereal::CarEvent,  ::capnp::Kind::STRUCT>>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void FrogPilotPlan::Builder::setFrogpilotEvents( ::capnp::List< ::cereal::CarEvent,  ::capnp::Kind::STRUCT>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::cereal::CarEvent,  ::capnp::Kind::STRUCT>>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::cereal::CarEvent,  ::capnp::Kind::STRUCT>::Builder FrogPilotPlan::Builder::initFrogpilotEvents(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::cereal::CarEvent,  ::capnp::Kind::STRUCT>>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void FrogPilotPlan::Builder::adoptFrogpilotEvents(
    ::capnp::Orphan< ::capnp::List< ::cereal::CarEvent,  ::capnp::Kind::STRUCT>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::cereal::CarEvent,  ::capnp::Kind::STRUCT>>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::cereal::CarEvent,  ::capnp::Kind::STRUCT>> FrogPilotPlan::Builder::disownFrogpilotEvents() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::cereal::CarEvent,  ::capnp::Kind::STRUCT>>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool FrogPilotPlan::Reader::getLateralCheck() const {
  return _reader.getDataField<bool>(
      ::capnp::bounded<98>() * ::capnp::ELEMENTS);
}

inline bool FrogPilotPlan::Builder::getLateralCheck() {
  return _builder.getDataField<bool>(
      ::capnp::bounded<98>() * ::capnp::ELEMENTS);
}
inline void FrogPilotPlan::Builder::setLateralCheck(bool value) {
  _builder.setDataField<bool>(
      ::capnp::bounded<98>() * ::capnp::ELEMENTS, value);
}

inline float FrogPilotPlan::Reader::getLaneWidthLeft() const {
  return _reader.getDataField<float>(
      ::capnp::bounded<7>() * ::capnp::ELEMENTS);
}

inline float FrogPilotPlan::Builder::getLaneWidthLeft() {
  return _builder.getDataField<float>(
      ::capnp::bounded<7>() * ::capnp::ELEMENTS);
}
inline void FrogPilotPlan::Builder::setLaneWidthLeft(float value) {
  _builder.setDataField<float>(
      ::capnp::bounded<7>() * ::capnp::ELEMENTS, value);
}

inline float FrogPilotPlan::Reader::getLaneWidthRight() const {
  return _reader.getDataField<float>(
      ::capnp::bounded<8>() * ::capnp::ELEMENTS);
}

inline float FrogPilotPlan::Builder::getLaneWidthRight() {
  return _builder.getDataField<float>(
      ::capnp::bounded<8>() * ::capnp::ELEMENTS);
}
inline void FrogPilotPlan::Builder::setLaneWidthRight(float value) {
  _builder.setDataField<float>(
      ::capnp::bounded<8>() * ::capnp::ELEMENTS, value);
}

inline float FrogPilotPlan::Reader::getMaxAcceleration() const {
  return _reader.getDataField<float>(
      ::capnp::bounded<9>() * ::capnp::ELEMENTS);
}

inline float FrogPilotPlan::Builder::getMaxAcceleration() {
  return _builder.getDataField<float>(
      ::capnp::bounded<9>() * ::capnp::ELEMENTS);
}
inline void FrogPilotPlan::Builder::setMaxAcceleration(float value) {
  _builder.setDataField<float>(
      ::capnp::bounded<9>() * ::capnp::ELEMENTS, value);
}

inline float FrogPilotPlan::Reader::getMinAcceleration() const {
  return _reader.getDataField<float>(
      ::capnp::bounded<10>() * ::capnp::ELEMENTS);
}

inline float FrogPilotPlan::Builder::getMinAcceleration() {
  return _builder.getDataField<float>(
      ::capnp::bounded<10>() * ::capnp::ELEMENTS);
}
inline void FrogPilotPlan::Builder::setMinAcceleration(float value) {
  _builder.setDataField<float>(
      ::capnp::bounded<10>() * ::capnp::ELEMENTS, value);
}

inline float FrogPilotPlan::Reader::getMtscSpeed() const {
  return _reader.getDataField<float>(
      ::capnp::bounded<11>() * ::capnp::ELEMENTS);
}

inline float FrogPilotPlan::Builder::getMtscSpeed() {
  return _builder.getDataField<float>(
      ::capnp::bounded<11>() * ::capnp::ELEMENTS);
}
inline void FrogPilotPlan::Builder::setMtscSpeed(float value) {
  _builder.setDataField<float>(
      ::capnp::bounded<11>() * ::capnp::ELEMENTS, value);
}

inline bool FrogPilotPlan::Reader::getRedLight() const {
  return _reader.getDataField<bool>(
      ::capnp::bounded<99>() * ::capnp::ELEMENTS);
}

inline bool FrogPilotPlan::Builder::getRedLight() {
  return _builder.getDataField<bool>(
      ::capnp::bounded<99>() * ::capnp::ELEMENTS);
}
inline void FrogPilotPlan::Builder::setRedLight(bool value) {
  _builder.setDataField<bool>(
      ::capnp::bounded<99>() * ::capnp::ELEMENTS, value);
}

inline float FrogPilotPlan::Reader::getSlcMapSpeedLimit() const {
  return _reader.getDataField<float>(
      ::capnp::bounded<12>() * ::capnp::ELEMENTS);
}

inline float FrogPilotPlan::Builder::getSlcMapSpeedLimit() {
  return _builder.getDataField<float>(
      ::capnp::bounded<12>() * ::capnp::ELEMENTS);
}
inline void FrogPilotPlan::Builder::setSlcMapSpeedLimit(float value) {
  _builder.setDataField<float>(
      ::capnp::bounded<12>() * ::capnp::ELEMENTS, value);
}

inline bool FrogPilotPlan::Reader::getSlcOverridden() const {
  return _reader.getDataField<bool>(
      ::capnp::bounded<100>() * ::capnp::ELEMENTS);
}

inline bool FrogPilotPlan::Builder::getSlcOverridden() {
  return _builder.getDataField<bool>(
      ::capnp::bounded<100>() * ::capnp::ELEMENTS);
}
inline void FrogPilotPlan::Builder::setSlcOverridden(bool value) {
  _builder.setDataField<bool>(
      ::capnp::bounded<100>() * ::capnp::ELEMENTS, value);
}

inline float FrogPilotPlan::Reader::getSlcOverriddenSpeed() const {
  return _reader.getDataField<float>(
      ::capnp::bounded<13>() * ::capnp::ELEMENTS);
}

inline float FrogPilotPlan::Builder::getSlcOverriddenSpeed() {
  return _builder.getDataField<float>(
      ::capnp::bounded<13>() * ::capnp::ELEMENTS);
}
inline void FrogPilotPlan::Builder::setSlcOverriddenSpeed(float value) {
  _builder.setDataField<float>(
      ::capnp::bounded<13>() * ::capnp::ELEMENTS, value);
}

inline float FrogPilotPlan::Reader::getSlcSpeedLimit() const {
  return _reader.getDataField<float>(
      ::capnp::bounded<14>() * ::capnp::ELEMENTS);
}

inline float FrogPilotPlan::Builder::getSlcSpeedLimit() {
  return _builder.getDataField<float>(
      ::capnp::bounded<14>() * ::capnp::ELEMENTS);
}
inline void FrogPilotPlan::Builder::setSlcSpeedLimit(float value) {
  _builder.setDataField<float>(
      ::capnp::bounded<14>() * ::capnp::ELEMENTS, value);
}

inline float FrogPilotPlan::Reader::getSlcSpeedLimitOffset() const {
  return _reader.getDataField<float>(
      ::capnp::bounded<15>() * ::capnp::ELEMENTS);
}

inline float FrogPilotPlan::Builder::getSlcSpeedLimitOffset() {
  return _builder.getDataField<float>(
      ::capnp::bounded<15>() * ::capnp::ELEMENTS);
}
inline void FrogPilotPlan::Builder::setSlcSpeedLimitOffset(float value) {
  _builder.setDataField<float>(
      ::capnp::bounded<15>() * ::capnp::ELEMENTS, value);
}

inline bool FrogPilotPlan::Reader::hasSlcSpeedLimitSource() const {
  return !_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline bool FrogPilotPlan::Builder::hasSlcSpeedLimitSource() {
  return !_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::Text::Reader FrogPilotPlan::Reader::getSlcSpeedLimitSource() const {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline  ::capnp::Text::Builder FrogPilotPlan::Builder::getSlcSpeedLimitSource() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline void FrogPilotPlan::Builder::setSlcSpeedLimitSource( ::capnp::Text::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), value);
}
inline  ::capnp::Text::Builder FrogPilotPlan::Builder::initSlcSpeedLimitSource(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::init(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), size);
}
inline void FrogPilotPlan::Builder::adoptSlcSpeedLimitSource(
    ::capnp::Orphan< ::capnp::Text>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::adopt(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::Text> FrogPilotPlan::Builder::disownSlcSpeedLimitSource() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::disown(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}

inline float FrogPilotPlan::Reader::getSpeedJerk() const {
  return _reader.getDataField<float>(
      ::capnp::bounded<16>() * ::capnp::ELEMENTS);
}

inline float FrogPilotPlan::Builder::getSpeedJerk() {
  return _builder.getDataField<float>(
      ::capnp::bounded<16>() * ::capnp::ELEMENTS);
}
inline void FrogPilotPlan::Builder::setSpeedJerk(float value) {
  _builder.setDataField<float>(
      ::capnp::bounded<16>() * ::capnp::ELEMENTS, value);
}

inline float FrogPilotPlan::Reader::getSpeedJerkStock() const {
  return _reader.getDataField<float>(
      ::capnp::bounded<17>() * ::capnp::ELEMENTS);
}

inline float FrogPilotPlan::Builder::getSpeedJerkStock() {
  return _builder.getDataField<float>(
      ::capnp::bounded<17>() * ::capnp::ELEMENTS);
}
inline void FrogPilotPlan::Builder::setSpeedJerkStock(float value) {
  _builder.setDataField<float>(
      ::capnp::bounded<17>() * ::capnp::ELEMENTS, value);
}

inline bool FrogPilotPlan::Reader::getSpeedLimitChanged() const {
  return _reader.getDataField<bool>(
      ::capnp::bounded<101>() * ::capnp::ELEMENTS);
}

inline bool FrogPilotPlan::Builder::getSpeedLimitChanged() {
  return _builder.getDataField<bool>(
      ::capnp::bounded<101>() * ::capnp::ELEMENTS);
}
inline void FrogPilotPlan::Builder::setSpeedLimitChanged(bool value) {
  _builder.setDataField<bool>(
      ::capnp::bounded<101>() * ::capnp::ELEMENTS, value);
}

inline bool FrogPilotPlan::Reader::getStscControllingCurve() const {
  return _reader.getDataField<bool>(
      ::capnp::bounded<102>() * ::capnp::ELEMENTS);
}

inline bool FrogPilotPlan::Builder::getStscControllingCurve() {
  return _builder.getDataField<bool>(
      ::capnp::bounded<102>() * ::capnp::ELEMENTS);
}
inline void FrogPilotPlan::Builder::setStscControllingCurve(bool value) {
  _builder.setDataField<bool>(
      ::capnp::bounded<102>() * ::capnp::ELEMENTS, value);
}

inline float FrogPilotPlan::Reader::getStscSpeed() const {
  return _reader.getDataField<float>(
      ::capnp::bounded<18>() * ::capnp::ELEMENTS);
}

inline float FrogPilotPlan::Builder::getStscSpeed() {
  return _builder.getDataField<float>(
      ::capnp::bounded<18>() * ::capnp::ELEMENTS);
}
inline void FrogPilotPlan::Builder::setStscSpeed(float value) {
  _builder.setDataField<float>(
      ::capnp::bounded<18>() * ::capnp::ELEMENTS, value);
}

inline float FrogPilotPlan::Reader::getTFollow() const {
  return _reader.getDataField<float>(
      ::capnp::bounded<19>() * ::capnp::ELEMENTS);
}

inline float FrogPilotPlan::Builder::getTFollow() {
  return _builder.getDataField<float>(
      ::capnp::bounded<19>() * ::capnp::ELEMENTS);
}
inline void FrogPilotPlan::Builder::setTFollow(float value) {
  _builder.setDataField<float>(
      ::capnp::bounded<19>() * ::capnp::ELEMENTS, value);
}

inline bool FrogPilotPlan::Reader::getTogglesUpdated() const {
  return _reader.getDataField<bool>(
      ::capnp::bounded<103>() * ::capnp::ELEMENTS);
}

inline bool FrogPilotPlan::Builder::getTogglesUpdated() {
  return _builder.getDataField<bool>(
      ::capnp::bounded<103>() * ::capnp::ELEMENTS);
}
inline void FrogPilotPlan::Builder::setTogglesUpdated(bool value) {
  _builder.setDataField<bool>(
      ::capnp::bounded<103>() * ::capnp::ELEMENTS, value);
}

inline float FrogPilotPlan::Reader::getUnconfirmedSlcSpeedLimit() const {
  return _reader.getDataField<float>(
      ::capnp::bounded<20>() * ::capnp::ELEMENTS);
}

inline float FrogPilotPlan::Builder::getUnconfirmedSlcSpeedLimit() {
  return _builder.getDataField<float>(
      ::capnp::bounded<20>() * ::capnp::ELEMENTS);
}
inline void FrogPilotPlan::Builder::setUnconfirmedSlcSpeedLimit(float value) {
  _builder.setDataField<float>(
      ::capnp::bounded<20>() * ::capnp::ELEMENTS, value);
}

inline float FrogPilotPlan::Reader::getUpcomingSLCSpeedLimit() const {
  return _reader.getDataField<float>(
      ::capnp::bounded<21>() * ::capnp::ELEMENTS);
}

inline float FrogPilotPlan::Builder::getUpcomingSLCSpeedLimit() {
  return _builder.getDataField<float>(
      ::capnp::bounded<21>() * ::capnp::ELEMENTS);
}
inline void FrogPilotPlan::Builder::setUpcomingSLCSpeedLimit(float value) {
  _builder.setDataField<float>(
      ::capnp::bounded<21>() * ::capnp::ELEMENTS, value);
}

inline float FrogPilotPlan::Reader::getVCruise() const {
  return _reader.getDataField<float>(
      ::capnp::bounded<22>() * ::capnp::ELEMENTS);
}

inline float FrogPilotPlan::Builder::getVCruise() {
  return _builder.getDataField<float>(
      ::capnp::bounded<22>() * ::capnp::ELEMENTS);
}
inline void FrogPilotPlan::Builder::setVCruise(float value) {
  _builder.setDataField<float>(
      ::capnp::bounded<22>() * ::capnp::ELEMENTS, value);
}

inline bool FrogPilotPlan::Reader::getVtscControllingCurve() const {
  return _reader.getDataField<bool>(
      ::capnp::bounded<104>() * ::capnp::ELEMENTS);
}

inline bool FrogPilotPlan::Builder::getVtscControllingCurve() {
  return _builder.getDataField<bool>(
      ::capnp::bounded<104>() * ::capnp::ELEMENTS);
}
inline void FrogPilotPlan::Builder::setVtscControllingCurve(bool value) {
  _builder.setDataField<bool>(
      ::capnp::bounded<104>() * ::capnp::ELEMENTS, value);
}

inline float FrogPilotPlan::Reader::getVtscSpeed() const {
  return _reader.getDataField<float>(
      ::capnp::bounded<23>() * ::capnp::ELEMENTS);
}

inline float FrogPilotPlan::Builder::getVtscSpeed() {
  return _builder.getDataField<float>(
      ::capnp::bounded<23>() * ::capnp::ELEMENTS);
}
inline void FrogPilotPlan::Builder::setVtscSpeed(float value) {
  _builder.setDataField<float>(
      ::capnp::bounded<23>() * ::capnp::ELEMENTS, value);
}

}  // namespace

CAPNP_END_HEADER

